use anyhow::Context;
use cargo_metadata::{Metadata, MetadataCommand};
use cargo_toml::Manifest;
use std::path::PathBuf;
use tokio::{process::Child, sync::broadcast::Sender};

/// Returns the current project cargo metadata.
pub fn get_cargo_metadata() -> anyhow::Result<Metadata> {
    let metadata = MetadataCommand::new()
        .exec()
        .context("Failed to get cargo metadata")?;

    Ok(metadata)
}

/// Returns the default `target_dir` for the given release mode.
pub fn get_target_dir() -> anyhow::Result<PathBuf> {
    let metadata = get_cargo_metadata()?;
    let target_dir = metadata.target_directory.as_std_path().to_path_buf();
    Ok(target_dir)
}

/// Returns the `Cargo.toml` file data.
pub fn get_cargo_toml() -> anyhow::Result<Manifest> {
    let mut dir = std::env::current_dir()?;
    dir.push("Cargo.toml");

    let manifest = Manifest::from_path(&dir)
        .with_context(|| format!("Failed to read Cargo.toml file on: {}", dir.display()))?;
    Ok(manifest)
}

/// Returns the name of the executable generated by `cargo run`.
pub fn get_exec_name() -> anyhow::Result<String> {
    let cargo_toml = get_cargo_toml()?;

    let package = cargo_toml
        .package
        .ok_or_else(|| anyhow::anyhow!("Cargo.toml does not contains a [package]"))?;

    Ok(package.name)
}

/// Returns the `lib` name of the `Cargo.toml` file.
pub fn get_cargo_lib_name() -> anyhow::Result<String> {
    let cargo_toml = get_cargo_toml()?;

    if let Some(lib) = &cargo_toml.lib {
        if let Some(name) = &lib.name {
            return Ok(name.clone());
        }
    }

    tracing::warn!("Cargo.toml does not contains a [lib]");

    let package = cargo_toml
        .package
        .ok_or_else(|| anyhow::anyhow!("Cargo.toml does not contains a [package]"))?;

    Ok(package.name)
}

/// Waits for a child process until complete or interrupted with the given signal.
pub async fn wait_interruptible(
    mut child: Child,
    interrupt_signal: Option<Sender<()>>,
) -> anyhow::Result<bool> {
    let Some(interrupt_signal) = interrupt_signal else {
        let status = child.wait().await?;
        anyhow::ensure!(status.success(), "Process failed");
        return Ok(true);
    };

    let mut int = interrupt_signal.subscribe();

    tokio::select! {
        ret = child.wait() => {
            match ret {
                Ok(status) => {
                    anyhow::ensure!(status.success(), "Process failed");
                    Ok(true)
                },
                Err(err) => {
                    tracing::error!("Process failed: {err}");
                    Err(err.into())
                }
            }
        },
        ret = int.recv() => {
            child.kill().await?;

            if let Err(err) = ret {
                tracing::error!("{err}");
                return Err(err.into());
            }

            // Interrupted
            Ok(false)
        }
    }
}
